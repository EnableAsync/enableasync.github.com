<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kind 的一些使用心得</title>
    <url>/uncategorized/kind/</url>
    <content><![CDATA[<h1 id="Kind-的一些使用心得"><a href="#Kind-的一些使用心得" class="headerlink" title="Kind 的一些使用心得"></a>Kind 的一些使用心得</h1><p>因为 Kind 启动相比于 Minikube 更快，而且支持多 Node，所以现在换成了 Kind，这里记录一些 Kind 的使用心得。</p>
<h2 id="1-Kind-安装"><a href="#1-Kind-安装" class="headerlink" title="1. Kind 安装"></a>1. Kind 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64<br>chmod +x ./kind<br>mv ./kind /usr/bin/kind<br></code></pre></td></tr></table></figure>
<h2 id="2-使用-Kind-创建含有两个-Node-的-kubernetes-集群"><a href="#2-使用-Kind-创建含有两个-Node-的-kubernetes-集群" class="headerlink" title="2. 使用 Kind 创建含有两个 Node 的 kubernetes 集群"></a>2. 使用 Kind 创建含有两个 Node 的 kubernetes 集群</h2><h3 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h3><p>这里我创建了两个 Node，使用以下配置文件，并将其命名为 <code>kind.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># a cluster with 1 control-plane nodes and 2 workers</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br></code></pre></td></tr></table></figure>
<h3 id="2-创建集群"><a href="#2-创建集群" class="headerlink" title="2. 创建集群"></a>2. 创建集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo kind create cluster --config kind.yaml<br></code></pre></td></tr></table></figure>
<p>这里需要注意的点有：</p>
<ol>
<li>不要设置集群 name，在我本地，如果设置了 name 会导致 kubeconfig 无法导出。</li>
<li>要使用 sudo，在我本地，如果不使用 sudo 会导致无法创建集群，原因未知。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Creating cluster <span class="hljs-string">&quot;kind&quot;</span> ...<br> ✓ Ensuring node image (kindest/node:v1.21.1) 🖼<br> ✓ Preparing nodes 📦 📦 📦  <br> ✓ Writing configuration 📜 <br> ✓ Starting control-plane 🕹️ <br> ✓ Installing CNI 🔌 <br> ✓ Installing StorageClass 💾 <br> ✓ Joining worker nodes 🚜 <br>Set kubectl context to <span class="hljs-string">&quot;kind-kind&quot;</span><br>You can now use your cluster with:<br><br>kubectl cluster-info --context kind-kind<br></code></pre></td></tr></table></figure>
<p>如果出现以上信息表示创建成功，可以进行下一步。</p>
<h3 id="3-导出-kubeconfig"><a href="#3-导出-kubeconfig" class="headerlink" title="3. 导出 kubeconfig"></a>3. 导出 kubeconfig</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">kind export kubeconfig<br></code></pre></td></tr></table></figure>
<p>如果不使用这一步，会导致使用 <code>kubectl</code> 的时候必须加上 <code>sudo</code>，否则无法连接到 kubernetes。</p>
<h2 id="3-安装-kubernetes-dashboard"><a href="#3-安装-kubernetes-dashboard" class="headerlink" title="3. 安装 kubernetes-dashboard"></a>3. 安装 kubernetes-dashboard</h2><h3 id="1-使用-helm-安装-dashboard"><a href="#1-使用-helm-安装-dashboard" class="headerlink" title="1. 使用 helm 安装 dashboard"></a>1. 使用 helm 安装 dashboard</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Add kubernetes-dashboard repository</span><br>helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/<br><span class="hljs-comment"># Deploy a Helm Release named &quot;dashboard&quot; using the kubernetes-dashboard chart</span><br>helm install dashboard kubernetes-dashboard/kubernetes-dashboard<br></code></pre></td></tr></table></figure>
<h3 id="2-转发-dashboard-pod"><a href="#2-转发-dashboard-pod" class="headerlink" title="2. 转发 dashboard pod"></a>2. 转发 dashboard pod</h3><p>这一步的目的是在本地访问部署了 dashboard 的 pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> POD_NAME=$(kubectl get pods -n default -l <span class="hljs-string">&quot;app.kubernetes.io/name=kubernetes-dashboard,app.kubernetes.io/instance=dashboard&quot;</span> -o jsonpath=<span class="hljs-string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)<br>  <span class="hljs-built_in">echo</span> https://127.0.0.1:8443/<br>  kubectl -n default port-forward <span class="hljs-variable">$POD_NAME</span> 8443:8443<br></code></pre></td></tr></table></figure>
<p>之后会提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Forwarding from 127.0.0.1:8443 -&gt; 8443<br>Forwarding from [::1]:8443 -&gt; 8443<br></code></pre></td></tr></table></figure>
<p>说明转发成功，此时访问 <a href="https://127.0.0.1:8443/">https://127.0.0.1:8443/</a> ，注意是 https</p>
<h3 id="3-生成-token"><a href="#3-生成-token" class="headerlink" title="3. 生成 token"></a>3. 生成 token</h3><p>不出意外 dashboard 需要 token 来登录，使用以下步骤来生成 token：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl create serviceaccount dashboard -n default<br>kubectl create rolebinding def-ns-admin --clusterrole=admin --serviceaccount=default:def-ns-admin<br>kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=default:dashboard<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl describe sa dashboard<br>Name:                dashboard<br>Namespace:           default<br>Labels:              &lt;none&gt;<br>Annotations:         &lt;none&gt;<br>Image pull secrets:  &lt;none&gt;<br>Mountable secrets:   dashboard-token-vzzjn<br>Tokens:              dashboard-token-vzzjn<br>Events:              &lt;none&gt;<br></code></pre></td></tr></table></figure>
<p>这里可以看到 <code>dashboard-token-vzzjn</code> 就是我们需要的 token，使用以下命令显示具体内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl describe secret dashboard-token-vzzjn<br></code></pre></td></tr></table></figure>
<p>之后就可以将具体的 token 粘贴在 dashboard 中登录。</p>
]]></content>
      <tags>
        <tag>k8s, kind</tag>
      </tags>
  </entry>
  <entry>
    <title>算法整理</title>
    <url>/uncategorized/leetcode/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p>状态转移方程如下：</p>
<script type="math/tex; mode=display">
d p[i][j]=\left\{\begin{array}{l}
d p[i-1][j-1]+1, \text { 当且仅当 } x[i]=y[j] \\
0, \text { 当 } x[i] \ne y[j]
\end{array}\right.</script><p>按照上面方程实现的算法时间复杂度为 $O(n^2)$，空间复杂度为 $O(n^2)$。</p>
<p><img  src="../leetcode/d6f0b0e17ed6e13f5c042d172b1ddca782cb6aba589f5fcfea8944831614502f-image.png"  ><span class="image-caption">image.png</span></p>
<p>注意到，更新 $dp[i][j]$ 只需要上一列，即 $dp[i-1]$ 列，所以可以将空间复杂度降低为 $O(n)$，但是需要注意因为使用的是相同的数组列，所以字符串不相等时需要设置 $dp[j] = 0$，同时要注意从后向前更新数组，因为如果从前向后更新，那么当前的 $dp[j]$ 使用的是当前列刚刚更新过的数据，而我们需要的是上一列的数据，所以可以从后向前更新数据避免这个问题。</p>
<p>rust 代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dp = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; s2.len()];<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s1.len() &#123;<br>    <span class="hljs-comment">// 逆序迭代是因为更新a[i][j]需要a[i-1][j-1]</span><br>    <span class="hljs-comment">// 现在是一个数组，所以 a[j] 是原来的 a[i][j]，而我们需要的是 a[i-1][j]</span><br>    <span class="hljs-comment">// 所以从后向前迭代，a[j] 是原来的 a[i-1][j]</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..s2.len()).s2() &#123;<br>        <span class="hljs-keyword">if</span> s[i] == s2[j] &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                dp[j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> dp[j] &gt; max_len &#123;<br>                <span class="hljs-keyword">let</span> before_s2 = s2.len() - <span class="hljs-number">1</span> - j;<br>                <span class="hljs-keyword">if</span> before_s2 + dp[j] - <span class="hljs-number">1</span> == i &#123;<br>                    max_len = dp[j];<br>                    max_end = i;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 与之前不同，之前使用的是不同的列，所以不需要置0</span><br>            dp[j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>将字符串倒置之后求最长公共子串，并判断是否为回文子串，这里回文子串「由倒置字符串推出的原字符串末尾下标」与「i」应该相等。</p>
<p>代码中 <code>longest_palindrome1</code> 的求最长公共子串空间复杂度为 $O(n^2)$，<code>longest_palindrome2</code> 的求最长公共子串空间复杂度为 $O(n)$。</p>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Solution</span></span>;<br><br><span class="hljs-keyword">impl</span> Solution &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest_palindrome1</span></span>(s: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-keyword">if</span> s.len() &lt;= <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">let</span> rev: <span class="hljs-built_in">String</span> = s.chars().rev().collect();<br>        <span class="hljs-keyword">let</span> rev = rev.as_bytes();<br>        <span class="hljs-keyword">let</span> s = s.as_bytes();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dp = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; rev.len()]; s.len()];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> max_end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s.len() &#123;<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..rev.len() &#123;<br>                <span class="hljs-keyword">if</span> s[i] == rev[j] &#123;<br>                    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; max_len &#123;<br>                    <span class="hljs-comment">// 如果是回文串，那么「由倒置字符串推出的原字符串末尾下标」与「i」应该相等</span><br>                    <span class="hljs-comment">// 其中，倒置字符串的 rev.len() - 1 - j，也就是倒置之前的开始下标，减一是因为长度比下标多一</span><br>                    <span class="hljs-comment">// 再加上 dp[i][j] - 1，就是原字符串的末尾下标。abc，a的下标为0，长度为3，0+3为3，但是最大下标为2，所以需要减一</span><br>                    <span class="hljs-keyword">let</span> before_rev = rev.len() - <span class="hljs-number">1</span> - j;<br>                    <span class="hljs-keyword">if</span> before_rev + dp[i][j] - <span class="hljs-number">1</span> == i &#123;<br>                        max_len = dp[i][j];<br>                        max_end = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">str</span>::from_utf8(&amp;s[max_end + <span class="hljs-number">1</span> - max_len..max_end + <span class="hljs-number">1</span>])<br>            .unwrap()<br>            .to_string()<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest_palindrome2</span></span>(s: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-keyword">if</span> s.len() &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">let</span> rev: <span class="hljs-built_in">String</span> = s.chars().rev().collect();<br>        <span class="hljs-keyword">let</span> s = s.as_bytes();<br>        <span class="hljs-keyword">let</span> rev = rev.as_bytes();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> max_end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dp = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; rev.len()];<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..s.len() &#123;<br>            <span class="hljs-comment">// 逆序迭代是因为更新a[i][j]需要a[i-1][j-1]</span><br>            <span class="hljs-comment">// 现在是一个数组，所以 a[j] 是原来的 a[i][j]，而我们需要的是 a[i-1][j]</span><br>            <span class="hljs-comment">// 所以从后向前迭代，a[j] 是原来的 a[i-1][j]</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..rev.len()).rev() &#123;<br>                <span class="hljs-keyword">if</span> s[i] == rev[j] &#123;<br>                    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br>                        dp[j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> dp[j] &gt; max_len &#123;<br>                        <span class="hljs-keyword">let</span> before_rev = rev.len() - <span class="hljs-number">1</span> - j;<br>                        <span class="hljs-keyword">if</span> before_rev + dp[j] - <span class="hljs-number">1</span> == i &#123;<br>                            max_len = dp[j];<br>                            max_end = i;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 与之前不同，之前使用的是不同的列，所以不需要置0</span><br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">str</span>::from_utf8(&amp;s[max_end + <span class="hljs-number">1</span> - max_len..max_end + <span class="hljs-number">1</span>])<br>            .unwrap()<br>            .to_string()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="中心拓展算法"><a href="#中心拓展算法" class="headerlink" title="中心拓展算法"></a>中心拓展算法</h3><p>为了避免在之后的叙述中出现歧义，这里我们指出什么是“朴素算法”。</p>
<p>该算法通过下述方式工作：对每个中心位置 $i$ 在比较一对对应字符后，只要可能，该算法便尝试将答案加 $1$。</p>
<p>该算法是比较慢的：它只能在 $O(n^2)$ 的时间内计算答案。</p>
<p>该算法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">d2</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  d1[i] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt;= i - d1[i] &amp;&amp; i + d1[i] &lt; n &amp;&amp; s[i - d1[i]] == s[i + d1[i]]) &#123;<br>    d1[i]++;<br>  &#125;<br><br>  d2[i] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt;= i - d2[i] - <span class="hljs-number">1</span> &amp;&amp; i + d2[i] &lt; n &amp;&amp;<br>         s[i - d2[i] - <span class="hljs-number">1</span>] == s[i + d2[i]]) &#123;<br>    d2[i]++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python Version</span><br>d1 = [<span class="hljs-number">0</span>] * n<br>d2 = [<span class="hljs-number">0</span>] * n<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n):<br>    d1[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">0</span> &lt;= i - d1[i] <span class="hljs-keyword">and</span> i + d1[i] &lt; n <span class="hljs-keyword">and</span> s[i - d1[i]] == s[i + d1[i]]:<br>        d1[i] += <span class="hljs-number">1</span><br><br>    d2[i] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">0</span> &lt;= i - d2[i] - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i + d2[i] &lt; n <span class="hljs-keyword">and</span> s[i - d2[i] - <span class="hljs-number">1</span>] == s[i + d2[i]]:<br>        d2[i] += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="Manacher-算法12"><a href="#Manacher-算法12" class="headerlink" title="Manacher 算法12"></a>Manacher 算法<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_2" id="reffn_2">2</a></sup></h3><p>Manacher 算法是对中心拓展算法的优化，为了快速计算，我们维护已找到的最靠右的子回文串的 <strong>边界 $(l, r)$</strong>（即具有最大 $r$ 值的回文串，其中 $l$ 和 $r$ 分别为该回文串左右边界的位置）。初始时，我们置 $l = 0$ 和 $r = -1$（<em>-1</em>需区别于倒序索引位置，这里可为任意负数，仅为了循环初始时方便）。</p>
<p>现在假设我们要对下一个 $i$ 计算 $P[i]$，而之前所有 $P[]$ 中的值已计算完毕。我们将通过下列方式计算：</p>
<ul>
<li><p>如果 $i$ 位于当前子回文串之外，即 $i &gt; r$，那么我们调用朴素算法。</p>
<p>因此我们将连续地增加 $d_1[i]$，同时在每一步中检查当前的子串 $[i - P[i] \dots i +  P[i]]$（$P[i]$ 表示半径长度，下同）是否为一个回文串。如果我们找到了第一处对应字符不同，又或者碰到了 $s$  的边界，则算法停止。在两种情况下我们均已计算完 $P[i]$。此后，仍需记得更新 $(l, r)$。</p>
</li>
<li><p>现在考虑 $i \le r$ 的情况。我们将尝试从已计算过的 $P[]$ 的值中获取一些信息。首先在子回文串  $(l, r)$ 中反转位置 $i$，即我们得到 $j = l + (r - i)$。现在来考察值 $P[j]$。因为位置 $j$ 同位置  $i$ 对称，我们 <strong>几乎总是</strong> 可以置 $P[i] = P[j]$。</p>
<p>存在 <strong>棘手的情况</strong>，主要有以下：</p>
<ul>
<li><p>超出了 $r$</p>
<p><img  src="../leetcode/b0d52a5f30747e55ef09b3c7b7cfc23026e37040edc41f387263e8f8a0ba8f49-image.png"  ><span class="image-caption">图转自 LeetCode</span></p>
<p>当我们要求 $P [ i ]$ 的时候，$P [mirror] = 7$，而此时 $P [ i ]$ 并不等于 $7$，为什么呢，因为我们从 $i$ 开始往后数 $7$ 个，等于 $22$，已经超过了最右的 $r$，此时不能利用对称性了，但我们一定可以扩展到 $r$ 的，所以 $P [ i ]$ 至少等于 $r - i = 20 - 15 = 5$，会不会更大呢，我们只需要比较 $T [ r+1 ]$ 和 $T [ r+1 ]$ 关于 $i$ 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
</li>
<li><p>$P[i]$ 遇到了原字符串的左边界</p>
<p><img  src="../leetcode/714e6f768e67304fb7162ecac3ae85fcf23ad82a21456e8ca55ac2c8cfd2609e-image.png"  ><span class="image-caption">image.png</span></p>
<p>此时$P [ i<em>{mirror} ] = 1$，但是 $P [ i ]$ 赋值成 1 是不正确的，出现这种情况的原因是 $P [ i</em>{mirror} ]$ 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 $P [ i ]$ 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
</li>
<li><p>$i = r$</p>
<p>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</p>
</li>
</ul>
<p>考虑 $r$ 的更新</p>
<p>就这样一步一步的求出每个 $P [ i ]$，当求出的 $P [ i ]$ 的右边界大于当前的 $r$ 时，我们就需要更新 $r$ 为当前的回文串了。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote id="fn_1">
<sup>1</sup>. <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://oi-wiki.org/string/manacher/">https://oi-wiki.org/string/manacher/</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <tags>
        <tag>data structure, algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 的一些使用心得</title>
    <url>/linux/linux/</url>
    <content><![CDATA[<h1 id="按时间降序最近安装的程序"><a href="#按时间降序最近安装的程序" class="headerlink" title="按时间降序最近安装的程序"></a>按时间降序最近安装的程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> $(ls -1t /var/<span class="hljs-built_in">log</span>/dpkg.log*); <span class="hljs-keyword">do</span> <br>      zcat -f <span class="hljs-variable">$x</span> |tac |grep -e <span class="hljs-string">&quot; install &quot;</span> -e <span class="hljs-string">&quot; upgrade &quot;</span>; <br><span class="hljs-keyword">done</span> | awk -F <span class="hljs-string">&quot;:a&quot;</span> <span class="hljs-string">&#x27;&#123;print $1 &quot; :a&quot; $2&#125;&#x27;</span> |column -t<br></code></pre></td></tr></table></figure>
<h1 id="常用的一些-gnome-extensions"><a href="#常用的一些-gnome-extensions" class="headerlink" title="常用的一些 gnome extensions"></a>常用的一些 gnome extensions</h1><h2 id="ddterm"><a href="#ddterm" class="headerlink" title="ddterm"></a>ddterm</h2><ul>
<li>按 <code>F10</code> 快速启动命令行，再按 <code>F10</code> 隐藏，十分方便</li>
</ul>
<h2 id="Desktop-Icons-NG-DING"><a href="#Desktop-Icons-NG-DING" class="headerlink" title="Desktop Icons NG(DING)"></a>Desktop Icons NG(DING)</h2><p>在桌面上显示图标</p>
<h2 id="Lock-Keys"><a href="#Lock-Keys" class="headerlink" title="Lock Keys"></a>Lock Keys</h2><p>可以显示当前大小写状况</p>
<h2 id="NetSpeed"><a href="#NetSpeed" class="headerlink" title="NetSpeed"></a>NetSpeed</h2><p>显示当前网速</p>
<h2 id="TopIcons-Plus（在-gnome-40-之后使用-Ubuntu-Appindicators-替代）"><a href="#TopIcons-Plus（在-gnome-40-之后使用-Ubuntu-Appindicators-替代）" class="headerlink" title="TopIcons Plus（在 gnome 40 之后使用 Ubuntu Appindicators 替代）"></a>TopIcons Plus（在 gnome 40 之后使用 Ubuntu Appindicators 替代）</h2><p>在顶部显示图标</p>
<h2 id="Dash-to-Dock"><a href="#Dash-to-Dock" class="headerlink" title="Dash to Dock"></a>Dash to Dock</h2><p>在底部智能显示一个 Dock</p>
<h1 id="换-MAC-地址"><a href="#换-MAC-地址" class="headerlink" title="换 MAC 地址"></a>换 MAC 地址</h1><p>有的时候需要更换 linux 的 ip 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo ifconfig eth0 down<br>sudo ifconfig wlo1 hw ether 02:42:41:7d:b7:6e<br>sudo ifconfig wlo1 up<br></code></pre></td></tr></table></figure>
<p>这里 <code>eth0</code> 是网络 interface，ether 之后的参数就是 MAC 地址</p>
<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><h2 id="Fcitx-失效"><a href="#Fcitx-失效" class="headerlink" title="Fcitx 失效"></a>Fcitx 失效</h2><ol>
<li><p>使用 im-config 修复</p>
</li>
<li><p>可能是 fcitx 没有正常启动，即还是 ibus，可以修改 ~/.pam_environment</p>
</li>
<li><p>删除 /etc/profile.d/pop-im-ibus.sh</p>
<p><code>/etc/profile.d/pop-im-ibus.sh</code> （源文件： /etc/gdm3/Xsession ）设置了环境变量 <code>XMODIFIERS</code> ，在 <code>/etc/X11/Xsession.d/70im-config_launch</code> 中有如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$XMODIFIERS</span>&quot;</span> ] &amp;&amp; \  <span class="hljs-comment"># 如果环境变量 XMODIFIERS 没有被设置</span><br>   ...<br>   <span class="hljs-comment"># 设置环境变量以启动用户指定的输入法</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>
<p>因为 <code>XMODIFIERS</code> 被设置了，所以 <code>设置环境变量以启动用户指定的输入法</code> 没有执行，所以 fcitx 没有被启动。</p>
<p><code>/etc/profile.d/pop-im-ibus.sh</code> 第一次出现于 <code>pop-os_20.10_amd64_intel_4.iso</code> （发布于 2020 年 12 月中旬）</p>
<p>相关 issue，<a href="https://github.com/pop-os/pop/issues/1445">https://github.com/pop-os/pop/issues/1445</a></p>
</li>
</ol>
<h1 id="Dash-to-dock"><a href="#Dash-to-dock" class="headerlink" title="Dash to dock"></a>Dash to dock</h1><h2 id="Dash-to-dock-重叠问题"><a href="#Dash-to-dock-重叠问题" class="headerlink" title="Dash to dock 重叠问题"></a>Dash to dock 重叠问题</h2><p>   Pop os 自带的 Dock 与 Dash to dock 发生了重叠</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/share/gnome-shell/extensions<br>sudo mv cosmic-dock@system76.com cosmic-dock@system76.com.bak # 关闭自带的 dock<br></code></pre></td></tr></table></figure>
<p>   之后重启 gnome 即可解决</p>
<h1 id="Alt-Tab-时阻止相同应用叠加"><a href="#Alt-Tab-时阻止相同应用叠加" class="headerlink" title="Alt + Tab 时阻止相同应用叠加"></a>Alt + Tab 时阻止相同应用叠加</h1><p>在 gnome 设置中，打开 keyboard shortcut，将 <code>Switch windows</code> 设置为 <code>Alt + Tab</code> ，而不是默认的 <code>Switch applications</code>。</p>
<p>参考：<a href="https://superuser.com/questions/394376/how-to-prevent-gnome-shells-alttab-from-grouping-windows-from-similar-apps">https://superuser.com/questions/394376/how-to-prevent-gnome-shells-alttab-from-grouping-windows-from-similar-apps</a></p>
<h1 id="fluxion"><a href="#fluxion" class="headerlink" title="fluxion"></a>fluxion</h1><h2 id="扫描不到热点"><a href="#扫描不到热点" class="headerlink" title="扫描不到热点"></a>扫描不到热点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo airmon-ng<br>sudo airmon-ng start fluxwl0<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> FLUXIONAirmonNG=1<br></code></pre></td></tr></table></figure>
<p>执行上述命令后再运行 fluxion 即可。</p>
<h2 id="解除-53-端口被-systemd-resolved-占用"><a href="#解除-53-端口被-systemd-resolved-占用" class="headerlink" title="解除 53 端口被 systemd-resolved 占用"></a>解除 53 端口被 systemd-resolved 占用</h2><ol>
<li>先停用 systemd-resolved 服务</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">systemctl stop systemd-resolved<br></code></pre></td></tr></table></figure>
<ol>
<li>编辑 /etc/systemd/resolved.conf 文件</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>systemd/resolved.conf<br></code></pre></td></tr></table></figure>
<ol>
<li>换下面说明更改，然后按一下“esc”键，再输入“:wq”（不要输入引号），回车保存即可。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Resolve]</span><br><span class="hljs-attr">DNS</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>  <span class="hljs-comment">#取消注释，增加dns</span><br><span class="hljs-comment">#FallbackDNS=</span><br><span class="hljs-comment">#Domains=</span><br><span class="hljs-comment">#LLMNR=no</span><br><span class="hljs-comment">#MulticastDNS=no</span><br><span class="hljs-comment">#DNSSEC=no</span><br><span class="hljs-comment">#Cache=yes</span><br><span class="hljs-attr">DNSStubListener</span>=<span class="hljs-literal">no</span>  <span class="hljs-comment">#取消注释，把yes改为no</span><br></code></pre></td></tr></table></figure>
<ol>
<li>最后运行下面命令即可。</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">ln -sf <span class="hljs-regexp">/run/</span>systemd<span class="hljs-regexp">/resolve/</span>resolv.conf <span class="hljs-regexp">/etc/</span>resolv.conf<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Rust的一些学习心得</title>
    <url>/rust/rust/</url>
    <content><![CDATA[<h1 id="Rust-标准库-trait"><a href="#Rust-标准库-trait" class="headerlink" title="Rust 标准库 trait"></a>Rust 标准库 trait</h1><p>假设有以下变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> t = T::new()<br></code></pre></td></tr></table></figure>
<h2 id="impl-From-lt-U-gt-for-T"><a href="#impl-From-lt-U-gt-for-T" class="headerlink" title="impl From&lt;U&gt; for T"></a><code>impl From&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>From&lt;U&gt;</code> 则可以通过 <code>T::from(U)</code> 得到 <code>T</code>。</p>
<p>例如 <code>String</code> 实现了 <code>From&lt;&amp;str&gt;</code>，所以 <code>String</code> 可以从 <code>&amp;str</code> 生成。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> string = <span class="hljs-string">&quot;hello&quot;</span>.to_string();<br><span class="hljs-keyword">let</span> other_string = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-built_in">assert_eq!</span>(string, other_string);<br></code></pre></td></tr></table></figure>
<p><code>impl Into&lt;U&gt; for T</code></p>
<p>如果为 <code>T</code> 实现了 <code>Into&lt;U&gt;</code> 则可以通过 <code>t.into()</code> 消耗自己得到 <code>U</code>。</p>
<p>例如 <code>String</code> 类型实现了 <code>Into&lt;Vec&lt;u8&gt;&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_hello</span></span>&lt;T: <span class="hljs-built_in">Into</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt;&gt;(s: T) &#123;<br>   <span class="hljs-keyword">let</span> bytes = <span class="hljs-string">b&quot;hello&quot;</span>.to_vec();<br>   <span class="hljs-built_in">assert_eq!</span>(bytes, s.into());<br>&#125;<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>.to_string();<br>is_hello(s);<br></code></pre></td></tr></table></figure>
<p>在实际编程中，用来接收多种类型的参数，如 <code>Into&lt;String&gt;</code> 可以同时接收 <code>String</code> 和 <code>&amp;str</code>。</p>
<h2 id="impl-AsRef-lt-U-gt-for-T"><a href="#impl-AsRef-lt-U-gt-for-T" class="headerlink" title="impl AsRef&lt;U&gt; for T"></a><code>impl AsRef&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>AsRef&lt;U&gt;</code> 则可以通过 <code>t.as_ref()</code> 得到 <code>&amp;U</code>。</p>
<p>注：</p>
<ol>
<li>与 <code>Into&lt;U&gt;</code> 不同的是，<code>AsRef&lt;U&gt;</code> 只是类型转换，<code>t</code> 对象本身没有被消耗；</li>
<li><code>T: AsRef&lt;U&gt;</code> 中的 <code>T</code>，可以接受 资源拥有者（owned）类型，共享引用（shared referrence）类型 ，可变引用（mutable referrence）类型。</li>
</ol>
<p>例如 <code>String</code> 和 <code>&amp;str</code> 都实现了 <code>AsRef&lt;str&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_hello</span></span>&lt;T: <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">str</span>&gt;&gt;(s: T) &#123;<br>   <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;hello&quot;</span>, s.as_ref());<br>&#125;<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<br>is_hello(s);<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;hello&quot;</span>.to_string();<br>is_hello(s);<br></code></pre></td></tr></table></figure>
<h2 id="impl-AsMut-lt-U-gt-for-T"><a href="#impl-AsMut-lt-U-gt-for-T" class="headerlink" title="impl AsMut&lt;U&gt; for T"></a><code>impl AsMut&lt;U&gt; for T</code></h2><p>如果为 <code>T</code> 实现了 <code>AsRef&lt;U&gt;</code> 则可以通过 <code>t.as_mut()</code> 得到 <code>&amp;mut U</code>。</p>
<h2 id="impl-Borror-lt-U-gt-for-T"><a href="#impl-Borror-lt-U-gt-for-T" class="headerlink" title="impl Borror&lt;U&gt; for T"></a><code>impl Borror&lt;U&gt; for T</code></h2><p>如果 <code>T</code> 实现了 <code>Borrow&lt;U&gt;</code>，那么，<code>t</code> 可执行 <code>.borrow()</code> 操作，即 <code>t.borrow()</code>。操作的结果，我们得到了一个类型为 <code>&amp;U</code> 的新引用。</p>
<p><code>Borrow</code> 可以认为是 <code>AsRef</code> 的严格版本，它对普适引用操作的前后类型之间附加了一些其它限制。</p>
<p><code>Borrow</code> 的前后类型之间要求必须有内部等价性。不具有这个等价性的两个类型之间，不能实现 <code>Borrow</code>。</p>
<p><code>AsRef</code> 更通用，更普遍，覆盖类型更多，是 <code>Borrow</code> 的超集。</p>
<p>举例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Borrow;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check</span></span>&lt;T: Borrow&lt;<span class="hljs-built_in">str</span>&gt;&gt;(s: T) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;Hello&quot;</span>, s.borrow());<br>&#125;<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;Hello&quot;</span>.to_string();<br><br>check(s);<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br>check(s);<br></code></pre></td></tr></table></figure>
<h2 id="impl-BorrowMut-lt-U-gt-for-T"><a href="#impl-BorrowMut-lt-U-gt-for-T" class="headerlink" title="impl BorrowMut&lt;U&gt; for T"></a><code>impl BorrowMut&lt;U&gt; for T</code></h2><p>如果 <code>T</code> 实现了 <code>BorrowMut&lt;U&gt;</code>，那么，<code>t</code> 可执行 <code>.borrow_mut()</code> 操作，即 <code>t.borrow_mut()</code>。操作的结果我们得到类型为 <code>&amp;mut U</code> 的一个可变（mutable）引用。</p>
<h2 id="impl-ToOwned-for-T"><a href="#impl-ToOwned-for-T" class="headerlink" title="impl ToOwned for T"></a><code>impl ToOwned for T</code></h2><p><code>ToOwned</code> 为 <code>Clone</code> 的普适版本。它提供了 <code>.to_owned()</code> 方法，用于类型转换。</p>
<p>有些实现了 <code>Clone</code> 的类型 <code>T</code> 可以从引用状态实例 <code>&amp;T</code> 通过 <code>.clone()</code> 方法，生成具有所有权的 <code>T</code> 的实例。但是它只能由 <code>&amp;T</code> 生成 <code>T</code>。而对于其它形式的引用，<code>Clone</code> 就无能为力了。</p>
<p>而 <code>ToOwned</code> trait 能够从任意引用类型实例，生成具有所有权的类型实例。</p>
<h2 id="impl-Deref-for-T"><a href="#impl-Deref-for-T" class="headerlink" title="impl Deref for T"></a><code>impl Deref for T</code></h2><p><code>Deref</code> 是 <code>deref</code> 操作符 <code>*</code> 的 trait，比如 <code>*v</code>。</p>
<p>一般理解，<code>*t</code> 操作，是 <code>&amp;t</code> 的反向操作，即试图由资源的引用获取到资源的拷贝（如果资源类型实现了 <code>Copy</code>），或所有权（资源类型没有实现 <code>Copy</code>）。</p>
<p>Rust 中，本操作符行为可以重载。这也是 Rust 操作符的基本特点。本身没有什么特别的。</p>
<h3 id="强制隐式转换（coercion）"><a href="#强制隐式转换（coercion）" class="headerlink" title="强制隐式转换（coercion）"></a>强制隐式转换（coercion）</h3><p><code>Deref</code> 神奇的地方并不在本身 <code>解引</code> 这个意义上，Rust 的设计者在它之上附加了一个特性：<code>强制隐式转换</code>，这才是它神奇之处。</p>
<p>这种隐式转换的规则为：</p>
<p>一个类型为 <code>T</code> 的对象 <code>t</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>t</code> 的某个智能指针或引用（比如 <code>&amp;foo</code>）在应用的时候会自动转换成 <code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于 <code>AsRef</code>，而跟 <code>解引</code> 似乎风马牛不相及。实际里面有些玄妙之处。</p>
<p>Rust 编译器会在做 <code>*v</code> 操作的时候，自动先把 <code>v</code> 做引用归一化操作，即转换成内部通用引用的形式 <code>&amp;v</code>，整个表达式就变成 <code>*&amp;v</code>。这里面有两种情况：</p>
<ol>
<li>把其它类型的指针（比如在库中定义的，<code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Cow</code> 等），转成内部标准形式 <code>&amp;v</code>；</li>
<li>把多重 <code>&amp;</code> （比如：<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>），简化成 <code>&amp;v</code>（通过插入足够数量的 <code>*</code> 进行解引）。</li>
</ol>
<p>所以，它实际上在解引用之前做了一个引用的归一化操作。</p>
<p>为什么要转呢？ 因为编译器设计的能力是，只能够对 <code>&amp;v</code> 这种引用进行解引用。其它形式的它不认识，所以要做引用归一化操作。</p>
<p>使用引用进行过渡也是为了能够防止不必要的拷贝。</p>
<p>下面举一些例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(s: &amp;<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-comment">// borrow a string for a second</span><br>&#125;<br><br><span class="hljs-comment">// String implements Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> owned = <span class="hljs-string">&quot;Hello&quot;</span>.to_string();<br><br><span class="hljs-comment">// therefore, this works:</span><br>foo(&amp;owned);<br></code></pre></td></tr></table></figure>
<p>因为 <code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(s: &amp;<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-comment">// borrow a string for a second</span><br>&#125;<br><br><span class="hljs-comment">// String implements Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> owned = <span class="hljs-string">&quot;Hello&quot;</span>.to_string();<br><span class="hljs-keyword">let</span> counted = Rc::new(owned);<br><br><span class="hljs-comment">// therefore, this works:</span><br>foo(&amp;counted);<br></code></pre></td></tr></table></figure>
<p>因为 <code>Rc&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=T&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(s: &amp;[<span class="hljs-built_in">i32</span>]) &#123;<br>    <span class="hljs-comment">// borrow a slice for a second</span><br>&#125;<br><br><span class="hljs-comment">// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;</span><br><span class="hljs-keyword">let</span> owned = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>foo(&amp;owned);<br></code></pre></td></tr></table></figure>
<p>因为 <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=[T]&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>;<br><br><span class="hljs-keyword">impl</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Foo&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> f = &amp;&amp;Foo;<br><br>f.foo();<br>(&amp;f).foo();<br>(&amp;&amp;f).foo();<br>(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();<br></code></pre></td></tr></table></figure>
<p>上面那几种函数的调用，效果是一样的。</p>
<p><code>coercion</code> 的设计，是 Rust 中仅有的类型隐式转换，设计它的目的，是为了简化程序的书写，让代码不至于过于繁琐。把人从无尽的类型细节中解脱出来，让书写 Rust 代码变成一件快乐的事情。</p>
<h2 id="Cow"><a href="#Cow" class="headerlink" title="Cow"></a><code>Cow</code></h2><p><code>Clone-on-write</code>，即写时克隆。本质上是一个智能指针。</p>
<p>它有两个可选值：</p>
<ul>
<li><code>Borrowed</code>，用于包裹对象的引用（通用引用）；</li>
<li><code>Owned</code>，用于包裹对象的所有者；</li>
</ul>
<p><code>Cow</code> 提供</p>
<ol>
<li>对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）；</li>
<li>如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，<code>Cow</code> 提供方法做克隆处理，并避免多次重复克隆。</li>
</ol>
<p><code>Cow</code> 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 <code>Cow</code>，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。</p>
<p>它有以下几个要点需要掌握：</p>
<ol>
<li><code>Cow&lt;T&gt;</code> 能直接调用 <code>T</code> 的不可变方法，因为 <code>Cow</code> 这个枚举，实现了 <code>Deref</code>；</li>
<li>在需要写 <code>T</code>的时候，可以使用 <code>.to_mut()</code> 方法得到一个具有所有权的值的可变借用；<ol>
<li>注意，调用 <code>.to_mut()</code> 不一定会产生克隆；</li>
<li>在已经具有所有权的情况下，调用 <code>.to_mut()</code> 有效，但是不会产生新的克隆；</li>
<li>多次调用 <code>.to_mut()</code> 只会产生一次克隆。</li>
</ol>
</li>
<li>在需要写 <code>T</code> 的时候，可以使用 <code>.into_owned()</code> 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象；<ol>
<li>如果之前 <code>Cow</code> 中的值是借用状态，调用此操作将执行克隆；</li>
<li>本方法，参数是<code>self</code>类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 <code>Cow</code> 上不能调用多次；</li>
</ol>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><code>.to_mut()</code> 举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cow: Cow&lt;[_]&gt; = Cow::Owned(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">let</span> hello = cow.to_mut();<br><br><span class="hljs-built_in">assert_eq!</span>(hello, &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>
<p><code>.into_owned()</code> 举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-keyword">let</span> cow: Cow&lt;[_]&gt; = Cow::Owned(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-keyword">let</span> hello = cow.into_owned();<br><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], hello);<br></code></pre></td></tr></table></figure>
<p>综合举例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">abs_all</span></span>(input: &amp;<span class="hljs-keyword">mut</span> Cow&lt;[<span class="hljs-built_in">i32</span>]&gt;) &#123;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..input.len() &#123;<br>        <span class="hljs-keyword">let</span> v = input[i];<br>        <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// clones into a vector the first time (if not already owned)</span><br>            input.to_mut()[i] = -v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h3><p>题目：写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。</p>
<p>对这个简单的问题，不用思考，我们都可以很快写出代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">remove_spaces</span></span>(input: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = <span class="hljs-built_in">String</span>::with_capacity(input.len());<br><br>   <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> input.chars() &#123;<br>      <span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>         buf.push(c);<br>      &#125;<br>   &#125;<br><br>   buf<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设计函数输入参数的时候，我们会停顿一下，这里，用 <code>&amp;str</code> 好呢，还是 <code>String</code> 好呢？思考一番，从性能上考虑，有如下结论：</p>
<ol>
<li>如果使用 <code>String</code> 则外部在调用此函数的时候，<ol>
<li>如果外部的字符串是 <code>&amp;str</code>，那么，它需要做一次克隆，才能调用此函数；</li>
<li>如果外部的字符串是 <code>String</code>，那么，它不需要做克隆，就可以调用此函数。但是，一旦调用后，外部那个字符串的所有权就被 <code>move</code> 到此函数中了，外部的后续代码将无法再使用原字符串。</li>
</ol>
</li>
<li>如果使用 <code>&amp;str</code>，则不存在上述两个问题。但可能会遇到生命周期的问题，需要注意。</li>
</ol>
<p>继续分析上面的例子，我们发现，在函数体内，做了一次新字符串对象的生成和拷贝。</p>
<p>让我们来仔细分析一下业务需求。最坏的情况下，如果字符串中没有空白字符，那最好是直接原样返回。这种情况做这样一次对象的拷贝，完全就是浪费了。</p>
<p>于是我们心想改进这个算法。很快，又遇到了另一个问题，返回值是 <code>String</code> 的嘛，我不论怎样，要把 <code>&amp;str</code> 转换成 <code>String</code> 返回，始终都要经历一次复制。于是我们快要放弃了。</p>
<p>好吧，<code>Cow</code> 君这时出马了。写出了如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Cow;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">remove_spaces</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(input: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">str</span>) -&gt; Cow&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-built_in">str</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> input.contains(<span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = <span class="hljs-built_in">String</span>::with_capacity(input.len());<br><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> input.chars() &#123;<br>            <span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>                buf.push(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Cow::Owned(buf);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Cow::Borrowed(input);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完美解决了业务逻辑与返回值类型冲突的问题。本例可细细品味。</p>
<p>外部程序，拿到这个 <code>Cow</code> 返回值后，按照我们上文描述的 <code>Cow</code> 的特性使用就好了。</p>
<h2 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a><code>Send</code> 和 <code>Sync</code></h2><p><code>std::marker</code> 模块中，有两个 trait：<code>Send</code> 和 <code>Sync</code>，它们与多线程安全相关。</p>
<p>标记为 <code>marker trait</code> 的 trait，它实际就是一种约定，没有方法的定义，也没有关联元素（associated items）。仅仅是一种约定，实现了它的类型必须满足这种约定。一种类型是否加上这种约定，要么是编译器的行为，要么是人工手动的行为。</p>
<p><code>Send</code> 和 <code>Sync</code> 在大部分情况下（针对 Rust 的基础类型和 std 中的大部分类型），会由编译器自动推导出来。对于不能由编译器自动推导出来的类型，要使它们具有 <code>Send</code> 或 <code>Sync</code> 的约定，可以由人手动实现。实现的时候，必须使用 <code>unsafe</code> 前缀，因为 Rust 默认不信任程序员，由程序员自己控制的东西，统统标记为 <code>unsafe</code>，出了问题（比如，把不是线程安全的对象加上 <code>Sync</code> 约定）由程序员自行负责。</p>
<p>它们的定义如下：</p>
<p>如果 <code>T: Send</code>，那么将 <code>T</code> 传到另一个线程中时（按值传送），不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Send</code> 是对象可以安全发送到另一个执行体中；</li>
<li><code>Send</code> 使被发送对象可以和产生它的线程解耦，防止原线程将此资源释放后，在目标线程中使用出错（use after free）。</li>
</ol>
<p>如果 <code>T: Sync</code>，那么将 <code>&amp;T</code> 传到另一个线程中时，不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Sync</code> 是可以被同时多个执行体访问而不出错；</li>
<li><code>Sync</code> 防止的是竞争；</li>
</ol>
<p>推论：</p>
<ol>
<li><code>T: Sync</code> 意味着 <code>&amp;T: Send</code>；</li>
<li><code>Sync + Copy = Send</code>；</li>
<li>当 <code>T: Send</code> 时，可推导出 <code>&amp;mut T: Send</code>；</li>
<li>当 <code>T: Sync</code> 时，可推导出 <code>&amp;mut T: Sync</code>；</li>
<li>当 <code>&amp;mut T: Send</code> 时，不能推导出 <code>T: Send</code>；</li>
</ol>
<p>（注：<code>T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>，<code>Box&lt;T&gt;</code> 等都是不同的类型）</p>
<p>具体的类型：</p>
<ol>
<li>原始类型（比如： u8, f64），都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>只包含原始类型的复合类型，都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>当 <code>T: Sync</code>，<code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code> 等集合类型是 <code>Sync</code>；</li>
<li>具有内部可变性的的指针，不是 <code>Sync</code> 的，比如 <code>Cell</code>, <code>RefCell</code>, <code>UnsafeCell</code>；</li>
<li><code>Rc</code> 不是 <code>Sync</code>。因为只要一做 <code>&amp;Rc&lt;T&gt;</code> 操作，就会克隆一个新引用，它会以非原子性的方式修改引用计数，所以是不安全的；</li>
<li>被 <code>Mutex</code> 和 <code>RWLock</code> 锁住的类型 <code>T: Send</code>，是 <code>Sync</code> 的；</li>
<li>原始指针（<code>*mut</code>, <code>*const</code>）既不是 <code>Send</code> 也不是 <code>Sync</code>；</li>
</ol>
<p>Rust 正是通过这两大武器：<code>所有权和生命周期</code> + <code>Send 和 Sync</code>（本质上为类型系统）来为并发编程提供了安全可靠的基础设施。使得程序员可以放心在其上构建稳健的并发模型。这也正是 Rust 的核心设计观的体现：内核只提供最基础的原语，真正的实现能分离出去就分离出去。并发也是如此。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://github.com/rustcc/RustPrimer">https://github.com/rustcc/RustPrimer</a></li>
</ol>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
</search>
